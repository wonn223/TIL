* 복습
함수의 인자가 값이 아닌 참조형인지 체크
: 인자가 참조 형태면 참조가 다른 참조를 물기 때문에 예상치 못한 부수효과가 발생한다.


## 루틴

###꼬리 물기 최적화
(현재 사파리만 지원해서 다른 브라우저의 경우 함수를 루프로 대체해야) - 스택 오버플로우를 방지한다. 
1)함수의 리턴에서 연쇄된 함수 호출이 일어나는 과정에서 각 함수가 리턴 포인트를 넘길 수 있어서 가능한 일. 단, 리턴에서 연산자를 사용하면 연산이 완료되기 전까지 피연산자들이 실행 스택이 계속 남아 있게 되므로, 연산자에 쓸 항을 인자에 저장시켜놓는다

런타임에서 메인 플로우 내부에 함수가 만들어질 때, 그 함수는 메인플로우의 변수에도 접근이 가능하다. 이 변수를 자유 변수(내부 함수의 변수도 아니고 글로벌 영역의 변수도 아닌 변수, 내부 변수가 구현되는 데 필요한 공통적인 내용을 담아 있다. *이 개념을 확장시키면 자바스크립트가 기존에 가지고 있는 도큐먼트, 렌더링 객체도 개발자가 자바스크립트로 구현한 모든 함수의 자유변수라 할 수 있다*.)라 한다. 자유변수를 사용할 수 있는 공간을 클로저라고 부른다. 클로저에 있는 함수는 외부의 모든 자유변수를 바라볼 수 있다. 이로 인한 문제를 막고자 클로저 안에 외부 자유변수와 이름이 같은 지역 변수를 만들면 된다.(쉐도잉) 쉐도잉과 클로저는 결국 함수의 영역을 명확히 구분짓고자 하는 데 있다.

###코루틴(coroutine)
입력과 출력이 여러 번 일어나는 루틴. 여러 번 연산이 일어나는 동안 루틴 내부(인자, 지역변수)가 초기화 되지 않고 메모리에 계속 유지되는 특징이 있다. 절차적인 행위를 순차적으로 통제하므로 랜덤화 된 행동을 막는다(게시판 로드 시 필요한 절차를 메소드를 중첩해서 부르기보다 코루틴에 로딩 순서에 맞게 쓰면 적절하다).  코루틴의 종류엔 함수 / 클래스 메소드 형태가 있다. yield와 같은 suspend기능(커서?)이 있어 동기 함수도 제어를 할 수 있다. (기본적으로 루프가 끝날 때가지 제어권을 못 가져온다)



