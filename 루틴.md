* 복습

함수의 인자가 값이 아닌 참조형인지 체크
: 인자가 참조 형태면 참조가 다른 참조를 물기 때문에 예상치 못한 부수효과가 발생한다. 객체 복사값/ primitive값을 인자로 사용한다.


## 루틴
: 입/출력을 하는 함수. 루틴 안에 루틴이 실행되면 스택 오버플로우가 발생한다.

### 문제 예방 : 꼬리 물기 최적화
스택 오버플로우를 방지하는 패턴.
1)함수의 리턴에서 연쇄된 함수 호출이 일어나는 과정에서 각 함수가 리턴 포인트를 넘길 수 있어서 가능한 일. 단, 리턴에서 연산자를 사용하면 연산이 완료되기 전까지 피연산자들이 실행 스택이 계속 남아 있게 되므로, 연산자에 쓸 항을 인자에 저장시켜놓는다

(현재 사파리만 지원해서 다른 브라우저의 경우 함수를 루프로 대체해야)


### 정적인 상태의 함수가 사용하는 변수는?
정적인 상태의 함수 : 파싱 시점에 함수의 정의가 확정되고, 수정할 가능성이 없는 함수를 말함. 라이브러리나 프레임워크에 미리 정해져 있는 메소드가 여기에 해당한다. 이 함수들은 자신이 가진 지역변수, 인자 그리고 함수 바깥의 전역변수를 참조할 수 있다.


### 런타임에서 함수가 생성되는 경우, 그 함수가 사용할 수 있는 변수는?
함수 내부의 지역 변수에 또 다른 함수를 할당하는 코드가 있다면 이 코드는 런타임 과정에서 구현된다. (함수를 만들 수 있는 대부분의 언어에서는 함수를 객체로 인식하고, 이를 변수에 할당하는 작업이 가능하다.) 이 때 새로 만들어진 함수는 자신이 처음부터 가진 인자/지역변수와 함께 자신이 있는 영역의 바깥 변수까지 인식할 수 있다. 이 변수를 자유변수라 한다.

>자유변수와 클로저는 런타임 시에 만들어진 함수가 다른 함수와 중첩된 영역을 형성할 때만 나타난다. 

그리고 자유변수를 사용할 수 있는 공간 또는 그 공간 안에 있는 함수를 클로저라고 부른다. 클로저에 있는 함수는 외부의 모든 변수를 자유변수로 바라볼 수 있다. 참조의 범위가 넓다는 점이 코드의 예측가능성?을 낮출 수 있는데, 참조의 범위를 조절하려는 목적으로 클로저 내부에 자유변수와 이름이 같은 변수를 하나 더 만들기도 한다(쉐도잉). 쉐도잉이 되면 루틴은 똑같은 이름을 가진 내부변수만을 바라보게 된다. 



```
// 글로벌 영역
window.a = 3 ;
if( a === 3) { // 블록영역
    const b = 5;
    const f1 = () => { // 함수(루틴)영역
        const c = 7;
        if( a + b + c) { // 블록 영역
            return p => p + a + b + c; // 함수(루틴) 영역
        } else {
            return p => p + a + b; // 함수(루틴) 영역
        }
    };
}
```
- return 문이 위치한 함수는 자신의 위로 존재하는 변수들( `const a,b,c`와 `window.a`)을 자유변수로 인식할 수 있다. `f1()`의 입장에서도 `constb`와 `window.a`를 자유변수로 인식할 수 있다. 자바스크립트가 가지고 있는 빌트인 객체도 개발자가 구현한 함수의 자유변수라 할 수 있다. 클로저가 있는 코드를 작성하려면, 여러 영역에 위치하고 있는 자유변수를 클로저 부분에서 어떻게 사용할 것인지 미리 생각해야 한다.



###코루틴(coroutine)
입력과 출력이 여러 번 일어나는 루틴. 여러 번 연산이 일어나는 동안 루틴 내부(인자, 지역변수)가 초기화 되지 않고 메모리에 계속 유지되는 특징이 있다. 절차적인 행위를 순차적으로 통제하므로 랜덤화 된 행동을 막는다(게시판 로드 시 필요한 절차를 메소드를 중첩해서 부르기보다 코루틴에 로딩 순서에 맞게 쓰면 적절하다).  코루틴의 종류엔 함수 / 클래스 메소드 형태가 있다. yield와 같은 suspend기능(커서?)이 있어 동기 함수도 제어를 할 수 있다. (기본적으로 루프가 끝날 때가지 제어권을 못 가져온다)



